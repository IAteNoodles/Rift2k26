"""
Backend/graphrag.py
────────────────────────────────────────────────────────────────
PGx Knowledge-Graph × GraphRAG (neo4j-graphrag pipeline)

• Neo4j `drugs` database  – PrimeKG PGx subgraph
• All Cypher is HARDCODED / parameterised  →  NO LLM-generated Cypher
• Multi-hop traversal (1 – 3 hops) from PharmacogeneCore → Drug
• LLM  :  Groq llama-3.3-70b-versatile  (primary)
          Ollama qwen2.5:7b-instruct     (fallback)
• Schema (from README):
    Nodes : PharmacogeneCore | Drug | GeneProtein | Disease
            Phenotype | MolecularFunction | DrugGeneSubgraph
    Rels  : DRUG_PROTEIN | DRUG_DRUG | PROTEIN_PROTEIN
            DRUG_EFFECT | PHENOTYPE_PROTEIN
    Seeds : CYP2D6, CYP2C19, CYP2C9, SLCO1B1, TPMT, DPYD
"""

from __future__ import annotations

import os
import sys
from typing import Any, Optional

# ── env ───────────────────────────────────────────────────────────────────────
try:
    from dotenv import load_dotenv
    load_dotenv()
except ImportError:
    pass

# ── third-party ───────────────────────────────────────────────────────────────
try:
    import neo4j
except ImportError:
    sys.exit("Please install: pip install neo4j neo4j-graphrag groq ollama python-dotenv")

from groq import Groq

try:
    import ollama as _ollama
    _OLLAMA_OK = True
except ImportError:
    _OLLAMA_OK = False

from neo4j_graphrag.llm.base import LLMInterface
from neo4j_graphrag.llm.types import LLMResponse
from neo4j_graphrag.retrievers.base import Retriever
from neo4j_graphrag.types import RetrieverResult, RetrieverResultItem
from neo4j_graphrag.generation import GraphRAG


# ══════════════════════════════════════════════════════════════════════════════
#  CONFIG
# ══════════════════════════════════════════════════════════════════════════════
NEO4J_URI  = os.getenv("NEO4J_URI",      "bolt://localhost:7687")
NEO4J_USER = os.getenv("AURA_USER",      "neo4j")
NEO4J_PASS = os.getenv("AURA_PASSWORD",  "123456789")
GROQ_KEY   = os.getenv("GROQ_API_KEY",   "")
DATABASE   = "drugs"

SEED_GENES = frozenset({"CYP2D6", "CYP2C19", "CYP2C9", "SLCO1B1", "TPMT", "DPYD"})

GROQ_MODEL   = "llama-3.3-70b-versatile"
OLLAMA_MODEL = "qwen2.5:7b-instruct"


# ══════════════════════════════════════════════════════════════════════════════
#  HARDCODED CYPHER LIBRARY  (nothing here is ever generated by an LLM)
# ══════════════════════════════════════════════════════════════════════════════
CYPHER: dict[str, str] = {

    # ── hop 1 : PharmacogeneCore  -[DRUG_PROTEIN]->  Drug ────────────────────
    "hop1_gene_drug": """
        MATCH (g:PharmacogeneCore {name: $entity})-[r:DRUG_PROTEIN]-(d:Drug)
        RETURN g.name   AS gene,
               type(r)  AS relationship,
               d.name   AS drug,
               1        AS hops
        LIMIT $limit
    """,

    # ── hop 2 : gene → protein-partner (hop=1) → Drug ────────────────────────
    "hop2_gene_drug": """
        MATCH (g:PharmacogeneCore {name: $entity})
              -[r1]-(mid)
              -[r2:DRUG_PROTEIN|DRUG_DRUG]-(d:Drug)
        WHERE mid.hop = 1
        RETURN g.name              AS gene,
               type(r1)            AS rel1,
               mid.name            AS intermediate,
               labels(mid)[0]      AS intermediate_type,
               type(r2)            AS rel2,
               d.name              AS drug,
               2                   AS hops
        LIMIT $limit
    """,

    # ── hop 3 : gene → n1(hop=1) → n2(hop=2) → Drug ─────────────────────────
    "hop3_gene_drug": """
        MATCH (g:PharmacogeneCore {name: $entity})
              -[r1]-(n1)
              -[r2]-(n2)
              -[r3:DRUG_PROTEIN|DRUG_DRUG|DRUG_EFFECT]-(d:Drug)
        WHERE n1.hop = 1 AND n2.hop = 2
        RETURN g.name          AS gene,
               type(r1)        AS rel1,
               n1.name         AS hop1_node,
               labels(n1)[0]   AS hop1_type,
               type(r2)        AS rel2,
               n2.name         AS hop2_node,
               labels(n2)[0]   AS hop2_type,
               type(r3)        AS rel3,
               d.name          AS drug,
               3               AS hops
        LIMIT $limit
    """,

    # ── drug → gene / phenotype / disease targets ─────────────────────────────
    "drug_targets": """
        MATCH (d:Drug {name: $entity})-[r]-(t)
        WHERE t:GeneProtein OR t:PharmacogeneCore
           OR t:Phenotype   OR t:Disease
        RETURN d.name          AS drug,
               type(r)         AS relationship,
               t.name          AS target,
               labels(t)[0]    AS target_type,
               t.hop           AS hop
        ORDER BY t.hop
        LIMIT $limit
    """,

    # ── drug–drug interactions ────────────────────────────────────────────────
    "drug_drug": """
        MATCH (d:Drug {name: $entity})-[r:DRUG_DRUG]-(d2:Drug)
        RETURN d.name   AS drug,
               type(r)  AS relationship,
               d2.name  AS interacting_drug
        LIMIT $limit
    """,

    # ── gene phenotype risk signals ───────────────────────────────────────────
    "gene_phenotypes": """
        MATCH (g:PharmacogeneCore {name: $entity})-[r:PHENOTYPE_PROTEIN]-(p:Phenotype)
        RETURN g.name   AS gene,
               type(r)  AS relationship,
               p.name   AS phenotype
        LIMIT $limit
    """,

    # ── shortest path between two named entities (max 4 hops) ────────────────
    "shortest_path": """
        MATCH (a {name: $start}), (b {name: $end})
        MATCH p = shortestPath((a)-[*..4]-(b))
        RETURN [n IN nodes(p)        | n.name]    AS path_nodes,
               [n IN nodes(p)        | labels(n)[0]] AS path_types,
               [r IN relationships(p)| type(r)]   AS path_rels,
               length(p)                           AS hops
    """,

    # ── per-gene hop-level drug counts ───────────────────────────────────────
    "gene_hop_summary": """
        MATCH (g:PharmacogeneCore {name: $entity})
        OPTIONAL MATCH (g)-[r1:DRUG_PROTEIN]-(d1:Drug)
        WITH g, count(DISTINCT d1) AS hop1_drugs
        OPTIONAL MATCH (g)-[r1a]-(mid)-[r2a:DRUG_PROTEIN|DRUG_DRUG]-(d2:Drug)
        WHERE mid.hop = 1
        WITH g, hop1_drugs, count(DISTINCT d2) AS hop2_drugs
        RETURN g.name AS gene, hop1_drugs, hop2_drugs
    """,
}

# ── focused path Cypher (scoped to one drug + one gene) ───────────────────────
_DRUG_GENE_HOPS: dict[int, str] = {
    1: """
        MATCH (g:PharmacogeneCore {name: $gene})-[r:DRUG_PROTEIN]-(d:Drug {name: $drug})
        RETURN g.name AS gene, type(r) AS rel, d.name AS drug, 1 AS hops
    """,
    2: """
        MATCH (g:PharmacogeneCore {name: $gene})-[r1]-(mid)-[r2:DRUG_PROTEIN|DRUG_DRUG]-(d:Drug {name: $drug})
        WHERE mid.hop = 1
        RETURN g.name AS gene, type(r1) AS rel1,
               mid.name AS intermediate, labels(mid)[0] AS mid_type,
               type(r2) AS rel2, d.name AS drug, 2 AS hops
    """,
    3: """
        MATCH (g:PharmacogeneCore {name: $gene})-[r1]-(n1)-[r2]-(n2)-[r3:DRUG_PROTEIN|DRUG_DRUG|DRUG_EFFECT]-(d:Drug {name: $drug})
        WHERE n1.hop = 1 AND n2.hop = 2
        RETURN g.name AS gene, type(r1) AS rel1,
               n1.name AS hop1_node, labels(n1)[0] AS hop1_type,
               type(r2) AS rel2,
               n2.name AS hop2_node, labels(n2)[0] AS hop2_type,
               type(r3) AS rel3, d.name AS drug, 3 AS hops
    """,
}

_DRUG_SEARCH_CYPHER = """
    MATCH (d:Drug)
    WHERE toLower(d.name) CONTAINS toLower($q) AND d.name IS NOT NULL
    RETURN DISTINCT d.name AS name
    ORDER BY d.name
    LIMIT 20
"""

_DRUG_GENE_SHORTPATH = """
    MATCH (g:PharmacogeneCore {name: $gene}), (d:Drug {name: $drug})
    MATCH p = shortestPath((g)-[*..5]-(d))
    RETURN [n IN nodes(p) | n.name]          AS path_nodes,
           [n IN nodes(p) | labels(n)[0]]    AS path_types,
           [r IN relationships(p) | type(r)] AS path_rels,
           length(p)                         AS hops
"""


# ══════════════════════════════════════════════════════════════════════════════
#  NEO4J HELPERS
# ══════════════════════════════════════════════════════════════════════════════
def get_driver() -> neo4j.Driver:
    return neo4j.GraphDatabase.driver(NEO4J_URI, auth=(NEO4J_USER, NEO4J_PASS))


def run_query(driver: neo4j.Driver, cypher: str, params: dict[str, Any]) -> list[dict]:
    with driver.session(database=DATABASE) as session:
        return [dict(r) for r in session.run(cypher, params)]


# ══════════════════════════════════════════════════════════════════════════════
#  ENTITY EXTRACTION  (pure string-matching — no LLM involved)
# ══════════════════════════════════════════════════════════════════════════════
_EntityCache = dict[str, set[str]]


def load_entity_caches(driver: neo4j.Driver) -> _EntityCache:
    """Pull gene & drug name sets from the DB once at startup."""
    print("  Loading entity caches from Neo4j …", end=" ", flush=True)
    genes = {r["name"] for r in run_query(
        driver, "MATCH (n:PharmacogeneCore) RETURN n.name AS name", {}
    )}
    drugs = {r["name"] for r in run_query(
        driver,
        "MATCH (n:Drug) WHERE n.name IS NOT NULL RETURN n.name AS name LIMIT 8000",
        {},
    )}
    print(f"done  ({len(genes)} genes, {len(drugs)} drugs)")
    return {"genes": genes, "drugs": drugs}


def extract_entities(question: str, caches: _EntityCache) -> dict[str, list[str]]:
    """
    Find gene / drug names mentioned in the question by case-insensitive
    substring match.  Falls back to all 6 seed genes when nothing is found.
    """
    q_lower = question.lower()
    found_genes = [g for g in caches["genes"] if g.lower() in q_lower]
    found_drugs = [d for d in caches["drugs"] if d.lower() in q_lower]

    if not found_genes:
        found_genes = [g for g in SEED_GENES if g.lower() in q_lower]

    return {"genes": found_genes, "drugs": found_drugs}


# ══════════════════════════════════════════════════════════════════════════════
#  LLM  :  Groq (primary)  →  Ollama qwen2.5:7b-instruct (fallback)
# ══════════════════════════════════════════════════════════════════════════════
_SYSTEM_PROMPT = (
    "You are a clinical pharmacogenomics expert. "
    "Answer ONLY from the provided graph context. "
    "Always cite gene names, drug names, hop distances, and relationship "
    "types from the context. Be concise and clinically precise."
)


class PGxLLM(LLMInterface):
    """
    neo4j-graphrag LLMInterface implementation.
    Primary  : Groq  llama-3.3-70b-versatile
    Fallback : Ollama qwen2.5:7b-instruct
    """

    def __init__(self) -> None:
        self._groq_client = Groq(api_key=GROQ_KEY) if GROQ_KEY else None
        if not self._groq_client:
            print("[LLM] Groq key not set — will use Ollama only.")

    def _groq(self, prompt: str, system: str) -> str:
        resp = self._groq_client.chat.completions.create(
            model=GROQ_MODEL,
            messages=[
                {"role": "system", "content": system},
                {"role": "user",   "content": prompt},
            ],
            temperature=0.1,
            max_tokens=1024,
        )
        return resp.choices[0].message.content

    def _ollama(self, prompt: str, system: str) -> str:
        if not _OLLAMA_OK:
            raise RuntimeError("ollama package not installed.")
        resp = _ollama.chat(
            model=OLLAMA_MODEL,
            messages=[
                {"role": "system", "content": system},
                {"role": "user",   "content": prompt},
            ],
        )
        return resp["message"]["content"]

    def invoke(
        self,
        input: str,
        message_history: Optional[Any] = None,
        system_instruction: Optional[str] = None,
    ) -> LLMResponse:
        system = system_instruction or _SYSTEM_PROMPT
        if self._groq_client:
            try:
                return LLMResponse(content=self._groq(input, system))
            except Exception as exc:
                print(f"[Groq error ({exc})] → falling back to Ollama …")
        return LLMResponse(content=self._ollama(input, system))

    async def ainvoke(
        self,
        input: str,
        message_history: Optional[Any] = None,
        system_instruction: Optional[str] = None,
    ) -> LLMResponse:
        return self.invoke(input, message_history, system_instruction)


# ══════════════════════════════════════════════════════════════════════════════
#  RETRIEVER  :  hardcoded Cypher, entity-based dispatch, multi-hop
# ══════════════════════════════════════════════════════════════════════════════
class PGxRetriever(Retriever):
    """
    Custom neo4j-graphrag Retriever.

    • No LLM-generated Cypher — all queries are from CYPHER dict above.
    • Entity extraction via string-matching.
    • Dispatches hop-1, hop-2, hop-3 queries per found gene.
    • Drug-centric queries when drug names are found.
    • Shortest-path query when ≥ 2 distinct entities are found.
    """

    def __init__(
        self,
        driver: neo4j.Driver,
        max_hops: int = 3,
        limit: int = 40,
    ) -> None:
        self.driver   = driver
        self.max_hops = max_hops
        self.limit    = limit
        self._caches  = load_entity_caches(driver)

    def search(self, query_text: str, **kwargs) -> RetrieverResult:  # type: ignore[override]
        entities = extract_entities(query_text, self._caches)
        rows: list[dict] = []

        # ── Gene-centric multi-hop ────────────────────────────────────────────
        target_genes = entities["genes"] or list(SEED_GENES)
        for gene in target_genes:
            params_g = {"entity": gene, "limit": self.limit}

            if self.max_hops >= 1:
                rows += run_query(self.driver, CYPHER["hop1_gene_drug"], params_g)

            if self.max_hops >= 2:
                rows += run_query(self.driver, CYPHER["hop2_gene_drug"], params_g)

            if self.max_hops >= 3:
                rows += run_query(
                    self.driver, CYPHER["hop3_gene_drug"],
                    {"entity": gene, "limit": self.limit // 2},
                )

            rows += run_query(
                self.driver, CYPHER["gene_phenotypes"],
                {"entity": gene, "limit": 20},
            )

        # ── Drug-centric retrieval ────────────────────────────────────────────
        for drug in entities["drugs"]:
            params_d = {"entity": drug, "limit": self.limit}
            rows += run_query(self.driver, CYPHER["drug_targets"], params_d)
            rows += run_query(
                self.driver, CYPHER["drug_drug"],
                {"entity": drug, "limit": 20},
            )

        # ── Shortest path between first gene / drug pair ─────────────────────
        all_found = entities["genes"] + entities["drugs"]
        if len(all_found) >= 2:
            rows += run_query(
                self.driver, CYPHER["shortest_path"],
                {"start": all_found[0], "end": all_found[1]},
            )

        context = self._format(rows, entities)
        return RetrieverResult(items=[RetrieverResultItem(content=context)])

    @staticmethod
    def _format(rows: list[dict], entities: dict) -> str:
        if not rows:
            return "No graph data found for the given entities."

        hop1: list[str] = []
        hop2: list[str] = []
        hop3: list[str] = []
        misc: list[str] = []

        for r in rows:
            hops = r.get("hops")

            if "path_nodes" in r:
                path_str = " → ".join(
                    f"{n} ({t})"
                    for n, t in zip(r["path_nodes"], r["path_types"])
                )
                misc.append(
                    f"  • [SHORTEST PATH {r['hops']} hops]  {path_str}\n"
                    f"    rels: {r['path_rels']}"
                )
            elif hops == 1 and "gene" in r:
                hop1.append(
                    f"  • {r['gene']} --[{r['relationship']}]--> {r['drug']}"
                )
            elif hops == 2 and "intermediate" in r:
                hop2.append(
                    f"  • {r['gene']} --[{r['rel1']}]--> "
                    f"{r['intermediate']} ({r['intermediate_type']}) "
                    f"--[{r['rel2']}]--> {r['drug']}"
                )
            elif hops == 3 and "hop1_node" in r:
                hop3.append(
                    f"  • {r['gene']} --[{r['rel1']}]--> "
                    f"{r['hop1_node']} ({r['hop1_type']}) "
                    f"--[{r['rel2']}]--> "
                    f"{r['hop2_node']} ({r['hop2_type']}) "
                    f"--[{r['rel3']}]--> {r['drug']}"
                )
            else:
                if "phenotype" in r:
                    misc.append(f"  • [PHENOTYPE]  {r.get('gene','')} → {r['phenotype']}")
                elif "interacting_drug" in r:
                    misc.append(
                        f"  • [DRUG_DRUG]  {r['drug']} ↔ {r['interacting_drug']}"
                    )
                elif "target" in r:
                    misc.append(
                        f"  • [DRUG_TARGET]  {r['drug']} --[{r['relationship']}]--> "
                        f"{r['target']} ({r['target_type']}, hop={r.get('hop','-')})"
                    )

        def _section(buf: list[str], title: str, items: list[str], cap: int = 30) -> None:
            if not items:
                return
            buf.append(f"── {title}  ({len(items)} edges) ──")
            buf += items[:cap]
            if len(items) > cap:
                buf.append(f"  … {len(items) - cap} more (truncated)")
            buf.append("")

        lines: list[str] = [
            "=== PGx Knowledge Graph Context ===",
            f"Entities matched → genes: {entities['genes']}  |  drugs: {entities['drugs']}",
            "",
        ]

        _section(lines, "HOP 1  [PharmacogeneCore → Drug direct]",     hop1, 40)
        _section(lines, "HOP 2  [Gene → intermediate → Drug]",          hop2, 30)
        _section(lines, "HOP 3  [Gene → n1 → n2 → Drug]",               hop3, 20)
        _section(lines, "Phenotypes / Drug-Drug interactions / Paths",   misc, 30)

        return "\n".join(lines)


# ══════════════════════════════════════════════════════════════════════════════
#  FOCUSED PATH API  —  scoped to one drug + one gene
# ══════════════════════════════════════════════════════════════════════════════
def search_drugs(driver: neo4j.Driver, q: str) -> list[str]:
    """Return up to 20 drug names matching substring q."""
    rows = run_query(driver, _DRUG_SEARCH_CYPHER, {"q": q})
    return [r["name"] for r in rows]


def path_drug_gene(
    driver: neo4j.Driver,
    drug: str,
    gene: str,
    hops: int = 1,
    max_hops: int = 3,
) -> dict:
    """
    Find connections between drug and gene.

    Starts at `hops`. If nothing is found at that level, automatically
    escalates up to `max_hops` (capped at 3) until results are found.

    Returns:
        drug          – queried drug name
        gene          – queried gene name
        effective_hop – the hop level where results were actually found
        requested_hop – what the caller asked for
        escalated     – True if we had to search beyond requested hops
        paths         – list of path dicts at the effective hop
        shortest      – shortest-path result (always included)
        found         – bool
    """
    hops     = max(1, min(hops,     3))
    max_hops = max(hops, min(max_hops, 3))

    shortest = run_query(driver, _DRUG_GENE_SHORTPATH, {"drug": drug, "gene": gene})

    effective_hop = hops
    rows: list[dict] = []
    for h in range(hops, max_hops + 1):
        rows = run_query(driver, _DRUG_GENE_HOPS[h], {"drug": drug, "gene": gene})
        effective_hop = h
        if rows:
            break

    return {
        "drug":          drug,
        "gene":          gene,
        "requested_hop": hops,
        "effective_hop": effective_hop,
        "escalated":     effective_hop > hops and bool(rows),
        "paths":         rows,
        "shortest":      shortest,
        "found":         bool(rows) or bool(shortest),
    }


# ══════════════════════════════════════════════════════════════════════════════
#  PUBLIC API  —  build pipeline
# ══════════════════════════════════════════════════════════════════════════════
def build_pipeline(max_hops: int = 3) -> tuple[GraphRAG, neo4j.Driver]:
    """
    Returns a configured (GraphRAG, driver) pair.

    Usage:
        rag, driver = build_pipeline(max_hops=3)
        result = rag.search(query_text="Which drugs interact with CYP2D6?")
        print(result.answer)
        driver.close()
    """
    driver    = get_driver()
    llm       = PGxLLM()
    retriever = PGxRetriever(driver, max_hops=max_hops)
    pipeline  = GraphRAG(llm=llm, retriever=retriever)
    return pipeline, driver
